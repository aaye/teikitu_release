/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/*  »Project«   Teikitu Gaming System (TgS) (∂)
    »File«      TgS Kernel [GPU] - Resource [HLSL] [Vertex].h
    »Author«    Andrew Aye (mailto: teikitu@andrewaye.com, https://www.andrew.aye.page)
    »Version«   5.20 | »GUID« DE461472-5528-4A5B-A7F4-09CCAD73387B */
/*  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ */
/*  Copyright: © 2002-2022, Andrew Aye.  All Rights Reserved.
    This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license,
    visit http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
/* == Kernel ===================================================================================================================================================================== */

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-. */
/*  Vertex Layout and Data Structure                                                                                                                                               */
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-. */

/* Not sure if its better on modern hardware (2022) to have compact vertices (i.e. position as a VEC3) or aligned vertices (i.e. position as a VEC4). Will need to test, for now
   will swap to using aligned vertices. */

#if !defined(RENDER_INPUT_LAYOUT_START_FIRST)
#define RENDER_INPUT_LAYOUT_START_FIRST RENDER_INPUT_LAYOUT_START
#define UNDEF_RENDER_INPUT_LAYOUT_START_FIRST
#endif

RENDER_INPUT_LAYOUT_START_FIRST(Vertex_UI,VERTEX_UI)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32_FLOAT, 0, 0, 0, TgVEC_S_F32_02_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32_FLOAT, 0, 0, TgVEC_S_F32_02_1, m_vUV0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( COLOR, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vCL )
RENDER_INPUT_LAYOUT_END(Vertex_UI)
RENDER_INPUT_ALIGNMENT_CHECK(32,Vertex_UI)

RENDER_INPUT_LAYOUT_START(Vertex_UI_Text,VERTEX_UI_TEXT)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32_FLOAT, 0, 0, 0, TgVEC_S_F32_02_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32_FLOAT, 0, 0, TgVEC_S_F32_02_1, m_vUV0 )
RENDER_INPUT_LAYOUT_END(Vertex_UI_Text)
RENDER_INPUT_ALIGNMENT_CHECK(16,Vertex_UI_Text)

RENDER_INPUT_LAYOUT_START(Vertex_Line,VERTEX_LINE)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( COLOR, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vCL )
RENDER_INPUT_LAYOUT_END(Vertex_Line)
RENDER_INPUT_ALIGNMENT_CHECK(32,Vertex_Line)


/* Vertex: Debug: Position */
RENDER_INPUT_LAYOUT_START(Vertex_Geom_00,VERTEX_GEOM_00)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_END(Vertex_Geom_00)
RENDER_INPUT_ALIGNMENT_CHECK(16,Vertex_Geom_00)

/* Vertex: Debug: Position, Colour */
RENDER_INPUT_LAYOUT_START(Vertex_Geom_01,VERTEX_GEOM_01)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( COLOR, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vCL )
RENDER_INPUT_LAYOUT_END(Vertex_Geom_01)
RENDER_INPUT_ALIGNMENT_CHECK(32,Vertex_Geom_01)

/* Vertex: Debug: Position, Normal */
RENDER_INPUT_LAYOUT_START(Vertex_Geom_02,VERTEX_GEOM_02)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( NORMAL, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vN0 )
RENDER_INPUT_LAYOUT_END(Vertex_Geom_02)
RENDER_INPUT_ALIGNMENT_CHECK(32,Vertex_Geom_02)

/* Vertex: Debug: Position, Normal, Colour */
RENDER_INPUT_LAYOUT_START(Vertex_Geom_03,VERTEX_GEOM_03)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( NORMAL, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vN0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( COLOR, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vCL )
RENDER_INPUT_LAYOUT_END(Vertex_Geom_03)
RENDER_INPUT_ALIGNMENT_CHECK(48,Vertex_Geom_03)



RENDER_INPUT_LAYOUT_START(Vertex_Particle_00,VERTEX_PARTICLE_00)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( COLOR, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vCL )
RENDER_INPUT_LAYOUT_END(Vertex_Particle_00)
RENDER_INPUT_ALIGNMENT_CHECK(48,Vertex_Particle_00)

RENDER_INPUT_LAYOUT_START(Vertex_Particle_01,VERTEX_PARTICLE_01)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vB0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( COLOR, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vCL )
RENDER_INPUT_LAYOUT_END(Vertex_Particle_01)
RENDER_INPUT_ALIGNMENT_CHECK(80,Vertex_Particle_01)



RENDER_INPUT_LAYOUT_START(Vertex_Mesh_00,VERTEX_MESH_00)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT1 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV0 )
RENDER_INPUT_LAYOUT_END(Vertex_Mesh_00)
RENDER_INPUT_ALIGNMENT_CHECK(64,Vertex_Mesh_00)

RENDER_INPUT_LAYOUT_START(Vertex_Mesh_01,VERTEX_MESH_01)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT1 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV1 )
RENDER_INPUT_LAYOUT_END(Vertex_Mesh_01)
RENDER_INPUT_ALIGNMENT_CHECK(80,Vertex_Mesh_01)

RENDER_INPUT_LAYOUT_START(Vertex_Mesh_02,VERTEX_MESH_02)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vB0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV )
RENDER_INPUT_LAYOUT_END(Vertex_Mesh_02)
RENDER_INPUT_ALIGNMENT_CHECK(64,Vertex_Mesh_02)



RENDER_INPUT_LAYOUT_START(Vertex_Morph_01,VERTEX_MORPH_01)
RENDER_INPUT_LAYOUT_PER_VERTEX( BLENDWEIGHT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_fBW0 )
RENDER_INPUT_LAYOUT_PER_VERTEX( BLENDWEIGHT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vBW1 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( BLENDINDICES, 0, ETgKN_GPU_EXT_FORMAT_R16G16B16A16_UINT, 0, 0, TgUINT_E16, m_uiBI0[4] )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( BLENDINDICES, 1, ETgKN_GPU_EXT_FORMAT_R16G16B16A16_UINT, 0, 0, TgUINT_E16, m_uiBI1[4] )
RENDER_INPUT_LAYOUT_END(Vertex_Morph_01)
RENDER_INPUT_ALIGNMENT_CHECK(48,Vertex_Morph_01)



RENDER_INPUT_LAYOUT_START(Vertex_Mesh_00_Morph_01,VERTEX_MESH_00_MORPH_01)
RENDER_INPUT_LAYOUT_PER_VERTEX( POSITION, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, 0, TgVEC_F32_04_1, m_vS0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TANGENT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vT1 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( TEXCOORD, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_vUV1 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( BLENDWEIGHT, 0, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_fBW0 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( BLENDWEIGHT, 1, ETgKN_GPU_EXT_FORMAT_R32G32B32A32_FLOAT, 0, 0, TgVEC_F32_04_1, m_fBW1 )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( BLENDINDICES, 0, ETgKN_GPU_EXT_FORMAT_R16G16B16A16_UINT, 0, 0, TgUINT_E16, m_uiBI0[4] )
RENDER_INPUT_LAYOUT_PER_VERTEX_APPEND( BLENDINDICES, 1, ETgKN_GPU_EXT_FORMAT_R16G16B16A16_UINT, 0, 0, TgUINT_E16, m_uiBI1[4] )
RENDER_INPUT_LAYOUT_END(Vertex_Mesh_00_Morph_01)
RENDER_INPUT_ALIGNMENT_CHECK(128,Vertex_Mesh_00_Morph_01)

#if defined(UNDEF_RENDER_INPUT_LAYOUT_START_FIRST)
#undef RENDER_INPUT_LAYOUT_START_FIRST
#endif
